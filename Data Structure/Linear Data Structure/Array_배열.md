# 알고리즘  
유한한 단계를 통해 문제를 해결하기 위한 절차나 방법  
컴퓨터가 어떤 일을 수행하기 위한 단계적 방법  

#### 컴퓨터 분야에서 알고리즘을 표현하는 방법 2가지
- 의사코드(Pseudo Code)
- 순서도  
> **보다 좋은 알고리즘을 이해하고 활용하는 것**  
주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능함  
-> 어떤 알고리즘을 사용하여야 하는가 ? 

#### 좋은 알고리즘 ?
- 정확성 : 얼마나 정확하게 동작하는가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더이상 개선할 여지가 없이 최적화 되었는가

## 시간 복잡도(Time Complexity)  
실행되는 명령문의 개수를 계산 -> 실제 걸리는 시간을 대략적으로 측정  
### = 빅오(O) 표기법  
시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시  
계수(Coefficient)는 생략  
```
O(3n + 2) = O(3n) = O(n)
O(2n^2 + 10n + 100) = O(n^2)
O(4) = O(1)
```
빅오(O, big-O) : 입력값이 무한대로 향할 때, 함수의 상한을 설명하는 수학적 표기방법 (실행 시간)  
Amortized Insertion Time: 조회하는 데에는 O(1)의 비용 발생  
(크기가 용량만큼 차게 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업으로 O(n)의 비용이 발생)

## 배열 
> 포인터(Pointer) : 메모리 영역을 1바이트 단위로 가리키는 주소

배열  
: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조   
: 값 또는 변수 엘리먼트의 집합으로 구성된 구조  
: 하나 이상의 인덱스 또는 키로 식별됨  
: 고정된 크기만큼의 연속된 메모리 할당 (-> 미리 크기를 지정하지 않고 자동으로 re-sizing하는 배열인 동적 배열이 생김)   

파이썬의 동적 배열 자료형 : List
초깃값을 작게 잡아 배열을 생성하고, 데이터를 추가하면서 꽉 채워지면 배열을 늘리고 모두 복사하는 방식
(정적 배열 자료형은 없음)

### 1차원 배열
별도의 선언 방법이 없다면 변수에 처음 값을 할당할 때 생성  
이름: 프로그램에서 사용할 배열의 이름  
```python
arr = [] 
arr = list()
arr = [1,2,3]
arr = [0] * 10
```

### 2차원 리스트
2차원 이상의 다차원 list는 차원에 따라 index를 선언함  
2차원 리스트 선언 : 세로길이(행의 개수), 가로길이(열의 개수)가 필요  
파이썬에서는 데이터 초기화를 통해 변수 선언과 초기화가 가능 함  
```python
arr = [i for i in range(2,9) if i%2==0]
# [2, 4, 6, 8]
```

### 리스트 순회
- 지그재그 순회  
List의 행을 좌우로 순회하며 조사하는 방법 
```python
n = len(arr)
m = len(arr[0])

for i in range(len(arr)):
    for j in range(len(arr[0])):
        arr[i][j + (m - 1 - 2*j) * (i % 2)]
```


# 정렬
2개 이상의 자료를 특정 기준에 의해 오름차순 혹은 내림차순으로 재배열하는 것  
> #### 대표적인 정렬 방식의 종류
> - 버블정렬
> - 카운팅 정렬
> - 선택 정렬
> - 퀵 정렬
> - 삽입 정렬
> - 병합 정렬

## 버블 정렬
인접한 두 원소를 비교하며 자리를 계속 교환하는 방식  
시간 복잡도: **O(n^2)**
```python
def BubbleSort(arr, n):
    for i in range(n-1, -1, -1):
        for j in range(i, n-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```
## 카운팅 정렬
항목들의 순서를 결정하기 위하여 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형 시간에 정렬을 하는 효율적인 알고리즘  
> 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능   

시간 복잡도: **O(n + k)**  # n은 리스트의 길이, k는 정수의 최대값
```python
def CountingSort(arr, sorted_arr, n):
    # arr = 입력배열(1~n)
    # sorted_arr = 정렬된 배열
    # count_arr = 카운트 배열
    sorted_arr = [0] * (n + 1)
    count_arr = [0] * (n + 1)
    for i in range(len(arr)):
        count_arr[arr[i]] += 1
    
    for i in range(1, len(count_arr)):
        count_arr[i] += count_arr[i-1]

    for i in range(len(sorted_arr)-1, -1, -1):
        count_arr[arr[i]] -= 1
        sorted_arr[count_arr[arr[i]]] = arr[i]
```
## 완전 검색 
문제의 해법이라고 생각할 수 있는 모든 경우의 수를 나열, 확인하는 방법  
= 브루트 포스/generate-and-test 기법  

> 자격평가시험 등에서 주어진 문제를 풀 때, 우선 완전 검색 기법으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인할 것!

### 순열
서로 다른 것들 중에서 몇 개를 뽑아 한줄로 나열하는 것  
- 서로 다른 n개 중에서 r개를 나열하는 것 
    - nPr = n * (n-1) * (n-2) * ... * (n-r+1)
- n개 중에서 n개를 뽑는 것
    - nPn = n! 
    - = n * (n-1) * (n-2) * ... * 2 * 1

## 탐욕 알고리즘 
- 최적해를 구하는 데 사용되는 근시안적 방법  
- 여러 경우 중 하나를 결정해야 할 때 마다 그 순간에 최적이라고 생각돠는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달  
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 해서 그것이 최적이라는 보장은 없음  
>1) 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 부분 해 집합에 추가(solution set)
>2) 실행 가능성 검사 : 새로운 부분해 집합이 실행가능한지를 확인  
>3) 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인

- baby-gin
```python
num = 456789
c = [0] * 12 #6자리 수로부터 각 자리수를 추출하여 개수를 누적할 리스트
# 왜 0~9까지가 아니라 0~11까지의 list를 만들었을까? 
# run을 조사할 때 굳이 7까지만 조사하라는 조건을 붙여 연산을 더 하게 하지 않고 메모리만 더 쓰는 방법으로 연산을 간소화함   

for i in range(6):
    c[num%10] += 1
    num //= 10

triplet = run = 0

i = 0  # 0부터 9번까지 확인
while i < 10:

    if c[i] >= 3: # triplet 조사 (i가 몇 개 있는지 확인) 후 데이터 삭제
        c[i] -= 3
        triplet += 1
        continue

    if c[i] >= 1 and c[i+1] >= c[i+2] >= 1: # run조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if triplet + run == 2 :
    print("baby gin")
else : 
    print("Lose")
```