## 성능 데이터 모델링의 개요

**데이터 모델의 성능 저하 요인**

- 데이터 모델 구조에 의해
- 데이터가 대용량이 됨으로 인해
- 인덱스 특성을 충분히 고려하지 않고 인덱스를 생성함으로 인해

<aside>
💡 **성능 데이터 모델링** : 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인 구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

</aside>

**성능 데이터 모델링 수행 시점**

초기에 성능을 분석할수록 비용이 들지 않음

분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무(Rework) 비용을 최소화 할 수 있는 기회를 가지게 된다.

******\*\*\*\*******\*\*******\*\*\*\*******\*\*\*\*******\*\*\*\*******\*\*******\*\*\*\*******성능 데이터 모델링 고려사항******\*\*\*\*******\*\*******\*\*\*\*******\*\*\*\*******\*\*\*\*******\*\*******\*\*\*\*******

① 데이터 모델링을 할 때 **정규화를 정확**하게 수행한다.
(정규화된 모델이 데이터를 주요 관심사별로 분산시키는 효과가 있음)
② 데이터베이스 **용량산정**을 수행한다.
(어떤 엔터티(테이블)에 데이터가 집중되는지 파악할 수 있다.)
③ 데이터베이스에 발생되는 **트랜잭션의 유형**을 파악한다.
④ **용량과 트랜잭션의 유형에 따라 반정규화**를 수행한다.
⑤ **이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정** 등을 수행한다.
⑥ **성능** 관점에서 데이터 모델을 **검증**한다.

## 정규화와 성능

********\*\*********\*\*********\*\*********\*\*********\*\*********\*\*********\*\*********정규화를 통한 성능 향상 전략********\*\*********\*\*********\*\*********\*\*********\*\*********\*\*********\*\*********

정규화를 하면 기본적으로 **데이터의 중복성을 제거**하고, **데이터가 관심사별로 처리**되는 경우가 많기 때문에 성능이 향상됨
하지만, 엔터티가 계속 발생하므로 조인이 많이 발생해서 성능이 저하되는 경우에는 반정규화를 하여야 성능이 향상될 수도 있음

<aside>
💡 성능 : 조회 성능, 입력/수정/삭제 성능

</aside>

**정규화**를 수행한다는 것: 데이터를 결정하는 결정자에 의해 **함수적 종속**을 가지고 있는 일반속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것

반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것
데이터의 중복속성을 제거하고 결정자에 의해 동일한 의미의 일반속성이 하나의 테이블로 집약됨

→ 정규화를 하면 **입력/수정/삭제 성능**은 `향상`되고, **조회 성능**은 `향상될 수도 저하될 수도` 있음

**정규화의 종류**

- 1차 정규화 : 같은 성격, 내용 컬럼이 연속될 때 컬럼 제거, 테이블 생성
- 2차 정규화 : PK 복합키 구성일 때, 부분적 함수 종속 관계 테이블 분리
- 3차 정규화 : PK가 아닌 일반 컬럼에 의존하는 컬럼 분리

**정규행 조건**

- 제1정규형 : 각 컬럼이 하나의 속성만을 가져야 함
  - 하나의 컬럼은 같은 종류나 타입의 값을 가짐
  - 각 컬럼이 유일한 이름을 가져야 함
  - 컬럼의 순서가 상관 없음
- 제2정규형 : 모든 컬럼이 **부분 종속성**이 없어야 함 → 기본키 중에서 특정 컬럼에만 종속되는 특징
- 제3정규형 : 기본키를 제외한 속성들 간의 **이행종속성**이 없어야 함 → `a->b, b->c, c->a`
- 제4정규형 : BCNF 모든 결정자가 후보키집합에 속함

다중 값을 가진다 → 제1정규형 위배
반복 그룹을 가진다 → 제1정규형 위배
모든 속성은 반드시 모든 기본 키에 종속되어야 한다. → 제2정규형
기본 키가 아닌 모든 속성 간에는 서로 종속될 수 없다. → 제3정규형

****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****반정규화된 테이블의 성능저하 사례****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****

1. 2차 정규화를 적용한 테이블에 대해서 조인을 하더라도 `PK Unique Index`를 이용하면 조인 성능 저하는 미미하게 발생

```sql
SELECT 직급명, B.관서번호, B.관서명
FROM 정부보관금관서원장 A, 관서 B
WHERE 직급코드 == 'AA' AND A.관서번호 = B.관서번호
```

1. 정규화하려면 복합식별자 중에서 일반속성(매각시간, 매각장소)이 주식별자 속성 중 일부(매각일자)에만 종속관계를 가지고 있으므로 2차 정규화의 대상이 된다.

```sql
SELECT B.총매각금액 , B.총유찰금액
FROM 매각기일 A, 매각일자별매각내역 B
WHERE A.매각장소 = '서울 7호' # <== 5천건의 데이터를 읽음
		AND A.매각일자 = B.매각일자
		AND A.매각장소 = B.매각장소;
```

1. 동일한 속성 형식을 두 개 이상의 속성으로 나열하여 반정규화한 경우

   한 테이블에 인덱스가 많아지면 조회 성능은 향상되지만 데이터 입력/수정/삭제 성능은 저하된다.

   위의 경우 각 유형별로 모두 인덱스가 걸려 있어야 인덱스에 의해 데이터를 찾을 수 있다.

   **중복속성에 대한 분리**가 **1차 정규화**의 정의임을 고려하면 모델 테이블은 1차 정규화의 대상이 된다.
   row 단위의 대상도 1차 정규화의 대상이 되지만 column 단위로 중복이 되는 경우도 1차 정규화의 대상이 된다.

1. 일재고와 일재고 상세를 구분함으로써 일재고에 발생되는 트랜잭션의 성능저하를 예방

**함수의 종속성(Functional Dependency) → 정규화**

: 데이터들이 어떤 기준값에 의해 종속되는 현상

`결정자(Determinant)` : 기준이 되는 값

`종속자(Dependent)` : 종속되는 값

---

엔터티 : 사람

속성 : 주민등록번호, 이름, 출생지, 호주

주민등록번호 : 결정자 이름, 출생지, 호주 : 종속자

주민등록번호가 이름, 출생지, 호주를 함수적으로 결정

## 반정규화와 성능

******\*\*******\*\*\*\*******\*\*******\*\*\*\*******\*\*******\*\*\*\*******\*\*******반정규화를 통한 성능 향상******\*\*******\*\*\*\*******\*\*******\*\*\*\*******\*\*******\*\*\*\*******\*\*******

**반정규화의 정의**

정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 **중복**, 통합, 분리 등을 수행하는 데이터 모델링의 기법

조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 성능 저하를 막기 위해서 수행

1. 일부 여러 개의 조인이 걸려야만 데이터를 가져오는 경우 → 조회 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려
2. 정규화의 함수 종속 관계는 위반하지 않지만 데이터의 중복성을 증가시켜야 조회 성능이 향상되는 경우 → 반 정규화 고려

`설계` 단계에서 반정규화 시행

****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****반정규화의 적용방법****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****\*\*\*\*****\*\*****

generally, **칼럼의 중복**을 통한 반정규화 → 무분별하면 데이터에 대한 무결성을 깨트릴 수 있음

칼럼의 반정규화 뿐만 아니라 테이블의 반정규화, 관계의 반정규화를 모두 고려해야

반정규화는 데이터의 무결성이 깨질 우려가 있기 때문에, `데이터의 무결성`을 보장하는 방법을 고려해야 함

1. 반정규화의 대상을 조사
   1. **범위 처리 빈도수 조사 :** 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고, 일정한 범위만을 조회하는 경우
   2. **대량의 범위 처리 조사** : 대량의 데이터 테이블에 대량의 데이터 범위를 자주 처리하는 경우에, 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
   3. **통계성 프로세스 조사 :** 통계성 프로세스에서 별도의 통계 테이블을 생성
   4. **테이블 조인 개수 :** 테이블에 지나치게 많은 조인이 걸려 데이터 조회가 어려운 경우
2. 반정규화의 대상에 대한 다른 방법 검토
   1. **뷰(View**) - 지나치게 많은 조인이 걸리는 경우
   2. **클러스터링(Clustering)** - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 & 인덱스 조정으로 해결 안되는 경우 & **for 조회 only**
   3. **인덱스 조정**
   4. **파티셔닝(Partitioning)** - 대량의 데이터는 **PK의 성격에 따라** 부분적인 테이블로 분리, 물리적인 저장 기법에 따라 성능을 향상시킴
   5. **응용 어플리케이션**에서 값을 **캐시**하거나, 중간 클래스에서 데이터를 캐시할 수 있음
3. 반정규화 적용

   테이블, 속성, 관계에 대해서 반정규화 가능

   중복, 추가, 분할, 제거 등의 방법으로 반정규화 가능

**반정규화의 기법**

**테이블 반정규화**

| 기법 분류                                          | 기법                      | 내용                                                                                                                                                         |
| -------------------------------------------------- | ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 테이블 병합                                        | 1:1 테이블 병합           | 해당 관계를 통합하여 성능향상                                                                                                                                |
|                                                    | 1:M 테이블 병합           | 상동                                                                                                                                                         |
|                                                    | 슈퍼/서브타입 테이블 병합 | 상동                                                                                                                                                         |
| 테이블 분할                                        | 수직 분할                 | 컬럼 단위의 테이블을 디스크 input/output으로 분산 처리하기 위해 테이블을 1:1로 분할하여 성능향상                                                             |
| (트랜잭션 처리 유형을 파악하는 것이 선행되어야 함) |
|                                                    | 수평 분할                 | 로우 단위로 집중 발생하는 트랜잭션을 분석하여 디스크 I/O 및 데이터접근의 효율성을 높여 성능을 향상하기 위해 로우 단위로 테이블을 분할(관계 없음) \_ 파티셔닝 |
| 테이블 추가                                        | 중복테이블 추가           | 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격조인을 제거하여 성능을 향상시킴                                                           |
|                                                    | 통계테이블 추가           | SUM, AVG 등 미리 계산을 수행해 둠으로써 조회 시 성능을 향상                                                                                                  |
|                                                    | 이력테이블 추가           | 이력 테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재하는 방법                                                                    |
|                                                    | 부분테이블 추가           | 자주 이용하는 집중화된 컬럼들이 있을 때, 디스크 I/O를 줄이기 위해서 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성                                   |

**\*\***\*\*\*\***\*\***\*\*\*\***\*\***\*\*\*\***\*\***칼럼(속성) 반정규화**\*\***\*\*\*\***\*\***\*\*\*\***\*\***\*\*\*\***\*\***

| 기법                               | 내용                                                                                                                              |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| 중복 컬럼 추가                     | 조인을 감소시키기 위해 중복 컬럼을 추가                                                                                           |
| 파생 컬럼 추가                     | Derived column, 미리 값을 계산하여 컬럼에 보관                                                                                    |
| 이력테이블 컬럼 추가               | 대량의 이력테이블을 처리할 때, 이력테이블에 기능성 컬럼(최근값 여부, 시작과 종료일자 등)을 추가                                   |
| PK에 의한 컬럼 추가                | 복합 의미를 갖는 PK를 단일 속성으로 구성한 경우, 해당 PK에서 특정 값을 별도로 조회하기 위해서 복합 PK의 일부를 일반 속성으로 추가 |
| 응용시스템 오작동을 위한 컬럼 추가 | 사용자가 데이터 처리를 하다가 잘못 처리하여 원래 값으로 복구하기를 원하는 경우, 이전 데이터를 임시적으로 중복하여 보관            |

**관계 반정규화**

| 기법           | 내용                                                                                                                              |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| 중복 관계 추가 | 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법 |

관계의 반정규화는 데이터 무결성을 깨트리지 않고 데이터 처리의 성능을 향상시킬 수 있음

- 테이블과 컬럼/속성의 반정규화는 데이터의 무결성을 깨트릴 수 있음

반정규화를 적용할 때 기억해야 할 내용은 데이터를 입력, 수정, 삭제할 때는 성능이 떨어지는 점을 기억해야 하고 데이터의 무결성 유지에 주의를 해야 한다.

## 대용량 데이터에 따른 성능

과하게 많은 컬럼은 로우 마이그레이션과 로우 체이닝을 발생시킨다.

<aside>
💡 **로우 마이그레이션(Row Migration)**

: 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

</aside>

<aside>
💡 **로우 체이닝(Row Chaining)**

: 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태

</aside>

로우체이닝과 로우마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와 I/O(입력/출력)가 발생할 때 불필요하게 I/O가 많이 발생하여 성능이 저하된다.

트랜잭션을 분리하여 적절하게 1:1 관계로 분리하여 성능을 향상시키자

**대량의 데이터 저장 및 처리 \_ PK에 의해 테이블을 분할하는 방법 `파티셔닝` : 논리적으로는 하나의 테이블이지만 물리적으로 여러 개의 테이블로 분리**

**Range Partitioning(범위)**

대상의 테이블이 날짜 혹은 숫자값으로 분리가 되고 각 영역별로 트랜잭션이 분리된다면 적용할 수 있음

데이터 보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능하므로(파티션테이블 DROP) 데이터보관주기에 따른 테이블 관리가 용이

**List Partitioning(특정 값 지)**

각각 값에 의해 파티셔닝이 됨

대용량 데이터를 특정값에 따라 분리 저장할 수는 있음

**\*\***\*\*\*\***\*\***\*\***\*\***\*\*\*\***\*\***Hash Partitioning(해쉬 적용)**\*\***\*\*\*\***\*\***\*\***\*\***\*\*\*\***\*\***

지정된 해시 조건에 따라 해시 알고리즘이 적용되어 테이블이 분리

but, 설계자는 테이블에 데이터가 정확히 어떻게 들어갔는지 모름

**********\*\*\*\***********\*\***********\*\*\*\***********\*\*\*\***********\*\*\*\***********\*\***********\*\*\*\***********테이블에 대한 수평분할/수직분할의 절차**********\*\*\*\***********\*\***********\*\*\*\***********\*\*\*\***********\*\*\*\***********\*\***********\*\*\*\***********

1. 데이터 모델링을 완성
2. 데이터베이스 용량산정
3. 대량 데이터가 처리되는 테이블에 대해서 **트랜잭션 처리 패턴을 분석**
4. 컬럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석

<aside>
💡 **컬럼** 수가 많은 경우, 트랜잭션의 특성에 따라 테이블을 **1:1형태로 분리**할 수 있는지 검증 ( 수직 분할 )
**데이터** 용량이 많은 경우, 테이블에 대해 **파티셔닝** 전략을 고려 ( 수평 분할 )

</aside>

## DB 구조와 성능

**슈퍼타입/서브타입 모델**

Extended ER-model

**공통** 부분을 **슈퍼타입**으로 모델링하고, **공통으로부터 상속**받아 **다른 엔터티와 차이**가 있는 속성에 대해서는 별도의 **서브엔터티**로 구분

논리적 데이터 모델에서 사용됨

********\*\*\*\*********\*\*\*\*********\*\*\*\*********\*\*********\*\*\*\*********\*\*\*\*********\*\*\*\*********슈퍼/서브 타입 데이터 모델의 변환 기술********\*\*\*\*********\*\*\*\*********\*\*\*\*********\*\*********\*\*\*\*********\*\*\*\*********\*\*\*\*********

1. **개별로 발생되는 트랜젝션에 대해서는 개별 테이블로 구성 (One to One Type)**
   1. 슈퍼타입과 서브타입 각각에 대해 발생하는 것
   2. 분리하여 1:1관계를 갖도록 함
2. **슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성(Plus Type)**
   1. 슈퍼타입 + 각 서브타입을 하나로 묶어서 별도의 테이블로 구성하는 것이 효율적
3. **전체를 하나로 묶어 트랜잭션이 발생할 때에는 하나의 테이블로 구성(Single Type, All in One Type)**
   1. 항상 통합하여 처리한다고 하면 불필요한 조인을 유발하거나 불필요한 union all과 같은 구문이 작성되어 성능이 저하됨

**인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상**

데이터베이스 테이블에서는 균형잡힌 트리구조의 B\*Tree구조를 많이 사용함 → sorted

**`PK순서`**

PK는 해당 테이블의 데이터를 접근할 때 가장 빈번하게 사용되는 유일한 인덱스를 모두 자동 생성한다.

**인덱스는 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 가장 좋은 효율을 나타낼 수 있음.**

**앞쪽에 위치한 속성 값이 가급적 `=` 아니면 최소한 범위 `BETWEEN` `<>` 가 들어와야 인덱스를 이용할 수 있다.**

FK - 데이터를 조회할 때 조인의 경로를 제공하는 역할 / **FK에 대해서는 반드시 인덱스를 생성해야,** 인덱스 칼럼의 순서도 조회의 조건을 고려하여 접근이 가장 효율적인 컬럼 순서대로 인덱스를 생성하도록 해야 함

PK의 순서를 인덱스 특징에 맞게 고려하지 않고 바로 그대로 생성하게 되면, 인덱스의 범위를 넓게 이용하거나 Full Scan을 유발하여 성능이 저하됨

물리적인 테이블에 FK제약이 걸려있지 않으면 인덱스 미생성으로 성능 저하

→ 물리적인 테이블에 FK 제약을 걸었을 때는 반드시 FK인덱스를 생성하도록 하기

→ 트랜잭션에 의해 거의 활용되지 않은 경우만 FK 인덱스를 지우는 방법을 선택

## 분산DB 데이터에 따른 성능

**분산 데이터베이스**

: 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스

: 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어있는 데이터들의 모임

: 물리적 Site 분산, 논리적으로 사용자 통합. 공유

**********\*\*\*\***********\*\***********\*\*\*\***********\*\***********\*\*\*\***********\*\***********\*\*\*\***********분산데이터베이스의 투명성(Transparency)**********\*\*\*\***********\*\***********\*\*\*\***********\*\***********\*\*\*\***********\*\***********\*\*\*\***********

1. 분할 투명성(단편성) : 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 사이트에 저장
2. 위치 투명성 : 데이터베이스의 저장 장소 명시 불필요함, 위치정보가 system catalog에 유지되어야 함
3. 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 매핑 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
4. 중복 투명성 : DB 객체가 여러 사이트에 중복되어 있는지 알 필요 없음
5. 장애 투명성 : 구성요소(DBMS, 컴퓨터 등)에 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성 : 다수의 트랜잭션이 동시에 수행시 결과의 일관성 유지. 타임 스탬프, 분산 2단계 로킹을 이용하여 구현

업무 특징에 따라 데이터 베이스 분산 구조를 설계해야

**분산 데이터 베이스의 장단점**

| 장점                                               | 단점                       |
| -------------------------------------------------- | -------------------------- |
| 지역 자치성, 점증적 시스템 용량 확장               | 소프트웨어 개발 비용       |
| 신뢰성과 가용성                                    | 오류의 잠재성 증대         |
| 효용성과 융통성                                    | 처리 비용의 증대           |
| 빠른 응답 속도와 통신 비용 절감(병목현상 ㄴㄴ라서) | 설계, 관리의 복잡성과 비용 |
| 시스템 규모의 적절한 조절                          | 불규칙한 응답 속도         |
| 각 지역 사용자의 요구 수용 증대                    | 통제의 어려움              |
|                                                    | 데이터 무결성에 대한 위협  |

원거리 혹은 다른 서버에 접속하여 처리하기 때문에 발생되는 네트워크의 부하 및 트랜잭션 집중에 따른 성능 저하의 원인을 분산된 DB환경으로 해결 → 빠른 성능

********\*\*********\*\*********\*\*********\*\*\*\*********\*\*********\*\*********\*\*********분산 데이터베이스의 적용 기법********\*\*********\*\*********\*\*********\*\*\*\*********\*\*********\*\*********\*\*********

1. 테이블 위치 분산

   테이블의 구조는 변하지 않고, 설계된 테이블의 위치만 각각 다르게 위치시키는 것

   테이블 위치가 위치별로 다르므로 테이블의 위치를 파악할 수 있는 도식화되니 위치별 데이터베이스 문서가 별도로 필요

2. **테이블 분할(Fragmenation) 분산**

   각각의 테이블을 쪼개어 분산하는 방법

   1. 수평 분할(Horizontal Fragmentation)

      테이블을 Row 단위로 분리

      데이터를 합쳐도 PK에 의한 중복이 발생하지 않는다

   2. 수직 분할(Vertical Fragmentation)

      테이블을 Column 단위로 분할

      column을 기준으로 분할하였기 때문에 각각 테이블에는 동일한 PK구조와 값이 있어야 한다

3. **테이블 복제(Replication) 분산**

   동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형

   부분 복제는 지사에서 CRUD가 되어 본사에서 이용하는 방식이 많고, 광역 복제는 본사에서 CRUD가 되어 지사에서 이용하는 형태가 많다.

   1. 부분 복제(Segment Replication)

      마스터 데이터베이스에서 테이블의 일부내용만 다른 지역이나 서버에 위치시킴

      통합된 테이블을 본사에 가지고 있으며넛 각 지사별로는 지사에 해당되는 로우를 가지고 있는 형태

   2. 광역 복제(Broadcast Replication)

      마스터 데이터베이스의 테이블의 내용을 각 지역이나 서버에 존재시킴

      통합된 테이블을 본사에 가지고 있으면서 각 지사에도 본사와 도일한 데이터를 모두 가지고 있는 형태

4. 테이블 요약(Summarization) 분산

   지역간 또는 서버 간에 데이터가 비슷하지만 서로 다은 유형으로 존재하는 경우

   1. 분석 요약(Rollup Summarization)

      각 지사별로 존재하는 동일한 내용을 바탕으로 한 요약 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 방법

   2. 통합 요약(Consolidation Summarization)

      각 지사별로 존재하는 다른 내용의 정보를 본사에서 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법

**분산 데이터 베이스를 사용하면 좋은 사례**

- 성능이 중요한 사이트
- 공통 코드, 기준 정보, 마스터 데이터 등에 대해서
- 실시간 동기화가 요구되지 않을 때
- 특정 서버에 부하가 집중될 때
- 백업사이트를 구성할 때도 간단한 분산 기능을 적용할 수 있음
