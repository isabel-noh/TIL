## 데이터 모델의 이해

**모델링의 정의**

모델 : 다양한 현상에 대해서 일정한 표기법에 의해 표현해 놓은 모형

현실 세계의 추상화된 표현

모델링 : 다양한 현상을 표기법에 의해 규칙을 가지고 표기하는 것

가설적 또는 일정 양식에 맞춘 표현

어떤 것에 대한 예비표현으로 그로부터 최종대상이 구축되도록 하는 계획으로서 기여하는 것

**복잡한 ‘현실세계’를 단순화시켜 표현**

**모델링의 특징**

1. 추상화(모형화, 가설적) : 다양한 현상을 일정한 양식인 표기법에 의해 표현
2. 단순화
3. 명확화 : 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확(正確)하게 현상을 기술하는 것

**모델링의 세가지 관점**

데이터 관점 : 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법 `What`

프로세스 관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법 `How`

데이터와 프로세스 상관관점 : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법 `Interaction`

**데이터 모델링의 정의**

• 정보시스템을 구축하기 위해, 해당 업무에 어떤 데이터가 존재하는지 또는 업무가 필요로 하는 정보는 무엇인지를 분석하는 방법

• 기업 업무에 대한 종합적인 이해를 바탕으로 **데이터에 존재하는 업무 규칙(Business Rule)에 대하여 참(True) 또는 거짓(False)을 판별할 수 있는 사실(사실명제)을** 데이터에 접근하는 방법(How), 사람(Who), 전산화와는 별개의(독립적인) 관점에서 이를 **명확하게 표현하는 추상화 기법**

• 데이터베이스를 구축하기 위한 분석/설계의 과정

**데이터 모델링에서 제공하는 기능**

• 시스템을 현재 혹은 원하는 모습으로 가시화하도록 도움

• 시스템의 구조와 행동을 명세화할 수 있게 함

• 시스템을 구축하는 구조화된 틀을 제공

• 시스템을 구축하는 과정에서 결정한 것을 문서화

• 다양한 영역에 집중하기 위해서 다른 영역의 세부 사항은 숨기는 다양한 관점을 제공

• 특정 목표에 따라 구체화된 상세 수준의 표현방법을 제공

********************\*\*********************\*\*********************\*\*********************데이터 모델링의 중요성 및 유의점********************\*\*********************\*\*********************\*\*********************

1. 파급효과(Leverage)
2. 복잡한 정보 요구사항의 간결한 표현(Conciseness)
3. 데이터의 품질(Data Quality)

---

1. 중복성
2. 비유연성
3. 비일관성

**********\*\*\*\***********\*\***********\*\*\*\***********데이터모델링의 3단계**********\*\*\*\***********\*\***********\*\*\*\***********

개념적 데이터 모델 → 논리적 데이터 모델 → 물리적 데이터 모델

**개념적 데이터 모델링:** 추상화 수준이 높고 업무중심적이고 **포괄적인 수준의 모델링을 진행**한다. - **엔터티** 중심

조직, 사용자의 데이터 요구사항을 찾고 분석하는데서 시작

핵심 엔터티와 그들 간의 관계를 발견하고, 그것을 표현하기 위해서 **엔터티-관계 다이어그램(ERD**)을 생성

전사적 데이터 모델(Enterprise Data Model)

**논리적 데이터 모델링**: 엔터티(Entity)중심의 상위 수준의 데이터 모델이 완성되면 업무의 구체적인 모습과 흐름에 따른 **구체화된 업무중심의 데이터 모델**을 만들어 내는데 이것을 논리적인 데이터 모델링이라고 한다.

**Key, 속성, 관계 등을 정확히 표현, 재사용성이 높음**

데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정

논리 데이터 모델의 상세화는 **식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의** 등을 들 수 있음

정규화를 본 과정에서 진행함

**물리적 데이터 모델링:** 논리적인 데이터 모델링 이후 데이터베이스의 저장구조에 따른 테이블스페이스 등을 고려한 방식을 물리적인 데이터 모델링이라고 한다.

데이터가 물리적으로 컴퓨터에 어떻게 저장될 것인가에 대한 정의

테이블, 칼럼 등으로 표현되는 물리적인 저장구조와 사용될 저장 장치, 자료를 추출하기 위해 사용될 접근 방법을 결정

**DB 성능따위를 고려하여 설계**

\***\*프로젝트 생명주기(Life Cycle)에서 데이터 모델링\*\***

객체지향 개념은 데이터와 프로세스를 한꺼번에 바라보면서 모델링을 전개하므로
데이터 모델링과 프로세스 모델링을 구분하지 않고 일체형으로 진행
(대표적인 예가 데이터(속성)와 프로세스(Method)가 같이 있는 클래스(Class))하게 된다.

**데이터 독립성 vs 데이터 종속성**

데이터독립성은 지속적으로 증가하는 유지보수 비용을 절감하고 데이터 복잡도를 낮추며 중복된 데이터를 줄이기 위한 목적이 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5305353a-e47b-49bf-9602-c5e80301d724/Untitled.png)
→ 각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.

→ 단계별 Schema에 따라 데이터 정의어(DDL)와 데이터 조작어(DML)가 다름을 제공한다.

**데이터 독립성의 3단계**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86d18a60-ec76-4f4e-bb1b-3be5e030405f/Untitled.png)

**데이터 독립성 요소**

- **외부스키마** : 개개 사용자가 보는 개인적 DB 스키마
  - DB의 개개인 사용자나 응용프로그래머가 접근하는 DB 정의
  - 사용자 관점
- **개념스키마** : 모든 사용자 관점을 통합한 조직 전체의 DB
  - DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마
- **내부스키마** : DB가 물리적으로 저장된 형식
  - 물리적 장치에서 실제로 DB가 저장되는 방법을 표현
  - 물리적 저장구조

데이터 모델링은 통합관점의 뷰를 가지고 있는 개념 스키마를 만들어가는 과정으로 이해할 수 있다.

**두 영역의 데이터 독립성**

- **논리적 독립성**
  - 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것
  - 논리적 구조가 변경되어도 응용 프로그램에는 영향이 없음
  - 사용자 특성에 맞는 변경 가능
  - 통합 구조 변경 가능
- **물리적 독립성**
  - 내부적 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않음
  - 저장 장치의 구조 변경은 응용프로그램과 개념스키마에 영향을 끼치지 않음
  - 물리적 구조 변경 없이 개념 구조 변경 가능
  - 개념 구조 영향 없이 물리적 구조 변경 가능

**사상(매핑) - 상호 독립적인 개념을 연결**

- **외부적/개념적 사상(논리적 사상)**
  - 외부적 뷰와 개념적 뷰의 연결
  - 외부 화면이나 사용자에게 인터페이스하기 위한 스키마 구조는 전체가 통합된 개념적 스키마와 연결된다는 것이 논리적 사상
- **개념적/내부적 사상(물리적 사상)**
  - 개념적 뷰와 저장된 DB의 상호관련성 정의
  - 저장된 데이터베이스의 구조가 바뀐다면, 개념적/내부적 사상도 바뀌어야 함→개념적 스키마가 그대로 남아있음
  - 통합된 개념적 스키마 구조와 물리적으로 저장된 구조의 물리적인 테이블스페이스와 연결되는 구조

**데이터 모델링의 세가지 요소**

→ 엔터티, 속성, 관계

- 어떤 것(Thing)
- 그것의 성격(Attributes)
- 업무가 관여하는 어떤 것 간의 관계 ( Relationship )

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cbdb6fd9-6226-4501-848a-fa5570578d20/Untitled.png)

**ERD**

ERD 그리는 순서

① 엔터티를 그린다. (사각형으로 표기)
② 엔터티를 적절하게 배치한다.
③ 엔터티간 관계를 설정한다.
④ 관계명을 기술한다.
⑤ 관계의 참여도를 기술한다.
⑥ 관계의 필수여부를 기술한다.

************\*\*\*\*************\*\*************\*\*\*\*************좋은 데이터 모델의 요소************\*\*\*\*************\*\*************\*\*\*\*************

- 완전성 : 업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의되어 있어야 한다.
- 중복 배제 : 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 한다.
  - 저장 공간 낭비, 중복데이터 이중처리 비용 등
- 업무 규칙 : 수많은 업무규칙(Business Rules)을 데이터 모델에 표현하고 이를 해당 데이터 모델을 활용하는 모든 사용자가 공유할 수 있도록 제공
- 데이터 재사용
  - 데이터의 통합성과 독립성에 대해 고려해야
  - 통합 모델이어야만 데이터의 재사용성을 높일 수 있다
  - 데이터가 애플리케이션에 대해 독립적으로 설계되어야만 데이터 재사용성을 향상시킬 수 있다.
- 의사소통 : 데이터 모델은 대상으로 하는 업무를 데이터 관점에서 분석하고 이를 설계하여 나오는 최종 산출물
- 통합성 : 가장 바람직한 데이터 구조의 형태는 동일한 데이터는 조직의 전체에서 한번 만 정의되고 다른 영역에서 참조, 활용하는 것

## Entity

**엔터티** : 저장되기 위한 어떤 것

엔터티는 그 집합에 속하는 개체들의 특성을 설명할 수 있는 **속성**(Attribute)을 가짐

```jsx
엔터티 : 학생
속성 : 학번, 학년, 이름, 이수학점, 등록일자, 생일, 주소 등

엔터티 : 과목
인스턴스 : 영어, 수학, 국어
```

엔터티 인스턴스 전체가 공유할 수 있는 공통 속성도 있고, 엔터티 인스턴스 중 일부에만 해당하는 개별 속성도 있을 수 있다.

**엔터티와 인스턴스**

**엔터티의 특징**

• 유일한 식별자에 의해 식별이 가능해야 한다. `ex) 사번`

• 영속적으로 존재하는 인스턴스의 집합이어야 한다.(2개 이상)

• 엔터티는 반드시 **속성(attribute)이** 있어야 한다.

**주식별자만 존재하고 일반속성은 전혀 없는 경우도 마찬가지로 적절한 엔터티라고 할 수 없다.**

**단, 예외적으로 관계엔터티(Associative Entity)의 경우는 주식별자 속성만 가지고 있어도 엔터티로 인정한다.**

• 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.

단, 데이터 모델링을 하면서 관계를 생략하여 표현해야 하는 경우는 다음과 같은 **통계성 엔터티 도출, 코드성 엔터티 도출, 시스템 처리시 내부 필요에 의한 엔터티 도출**과 같은 경우이다.

1. 통계를 위한 엔터티의 경우는 업무진행 엔터티로부터 통계업무만(Read Only)을 위해 별도로 엔터티를 다시 정의하게 되므로 엔터티간의 관계가 생략되는 경우에 해당한다.
2. 코드를 위한 엔터티의 경우 너무 많은 엔터티와 엔터티간의 관계 설정으로 인해 데이터 모델의 읽기효율성(Readability)이 저하되어 도저히 모델링 작업을 진행할 수 없게 된다. 또한 코드성 엔터티는 물리적으로 테이블과 프로그램 구현 이후에도 외부키에 의한 참조무결성을 체크하기 위한 규칙을 데이터베이스 기능에 맡기지 않는 경우가 대부분이기 때문에 논리적으로나 물리적으로 관계를 설정할 이유가 없다.
3. 시스템 처리시 내부 필요에 의한 엔터티(예를 들어, 트랜잭션 로그 테이블 등)의 경우 트랜잭션이 업무적으로 연관된 테이블과 관계 설정이 필요하지만 이 역시 업무적인 필요가 아니고 시스템 내부적인 필요에 의해 생성된 엔터티이므로 관계를 생략하게 된다.

******\*\*******\*\*\*\*******\*\*******엔터티의 분류******\*\*******\*\*\*\*******\*\*******

- 유무형에 따른 분류
  유형 엔터티 `ex) 사원, 물품, 강사`
  개념 엔터티 : 물리적으로 존재하지 않고, 관리해야할 개념으로 존재 `ex) 조직, 보험 상품 …`
  사건 엔터티 : 업무를 수행하면서 발생하는 엔터티 `ex) 주문, 청구, 미납 …`
- 발생 시점에 따른 분류
  기본 엔터티 : 그 업무에 원래 존재하는 정보로서 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고 자신은 타 엔터티의 부모의 역할을 하게 된다.
  자신의 고유한 주식별자를 가짐
  중심 엔터티 : 기본엔터티로부터 발생되고, 해당 업무에 있어서 중심적인 역할을 한다.
  다른 엔터티와의 관계를 통해 많은 행위엔터티를 생성한다.
  `ex) 계약, 사고, 예금 원장, 청구, 주문, 매출 등`
  행위 엔터티 : 행위엔터티는 두 개 이상의 부모엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가된다.
  `ex) 주문목록, 사원변경이력 등`
- …
  독립엔터티, 의존엔터티

## Attribute

**속성**

업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 **더 이상 분리되지 않는 최소의 데이터 단위**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/868090f0-123a-477d-83ab-e90b668ad95b/Untitled.png)

- 업무에서 필요로 한다.
- 의미상 더 이상 분리되지 않는다.
- 엔터티를 설명하고 인스턴스의 구성요소가 된다.

- 하나의 속성에는 한 개의 값만을 가진다. 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.

**속성의 분류**

- 기본 속성
- 설계 속성
- 파생 속성
- PK 속성
- FK 속성
- 일반 속성
- 단순 속성
- 복합 속성
- 속성 하나에 한 개의 값을 가지는 경우를 단일값(Single Value)
- 여러 개의 값을 가지는 경우를 다중값(Multi Value) 속성
  - 어떤 사람의 전화번호와 같은 속성은 집, 휴대전화, 회사 전화번호와 같이 여러 개의 값을 가질 수 있다.
- 다중값 속성의 경우 하나의 엔터티에 포함될 수 없으므로 1차 정규화를 하거나, 아니면 별도의 엔터티를 만들어 관계로 연결해야 한다.

**도메인**

속성의 값의 범위

**속성의 명명**

## Relationship

**관계**

엔터티와 엔터티 간 연관성을 표현

********\*\*\*\*********\*\*********\*\*\*\*********관계의 페어링********\*\*\*\*********\*\*********\*\*\*\*********

각각 인스턴스가 엔터티와 다른 종류의 관계를 가진다면 두 엔터티 사이에 두 개 이상의 관계를 형성하고 있을 수 있다.
각각의 엔터티의 인스턴스들은 자신이 관련된 인스턴스들과 관계의 어커런스로 참여하는 형태

**관계의 분류**

UML(Unified Modeling Language)에는 클래스다이어그램의 관계중 **연관관계(Association)**와 **의존관계(Dependency)**가 있다.
연관관계는 존재적 관계, 의존관계는 상대방 클래스의 행위에 의해 관계가 형성될 때
**연관관계는** 표현방법이 **실선**으로 표현되고 소스코드에서 멤버변수로 선언하여 사용하게 하고, **의존관계는 점선**으로 표현되고 행위를 나타내는 코드인 Operation(Method)에서 파라미터 등으로 이용할 수 있도록 되어 있다.

******\*\*\*\*******\*\*******\*\*\*\*******관계의 표기법******\*\*\*\*******\*\*******\*\*\*\*******

- 관계명(Membership) : 관계의 이름
- 관계차수(Cardinality) : 1:1, 1:M, M:N
- 관계선택사양(Optionality) : 필수관계, 선택관계

- 관계명 : 엔터티가 관계에 참여하는 형태를 지칭
  - 관계시작점 → 관계끝점
  - 애매한 동사 X, 현재형 O
- 관계차수(degree, cardinality) : 두 개의 엔터티간 관계에서 참여자의 수를 표현하는 것
  - 한 개가 참여하는 경우는 실선을 그대로 유지하고 다수가 참여한 경우는(Many) 까마귀발과 같은 모양으로 그려준다.
  1. 1:1(ONE TO ONE) 관계를 표시하는 방법
  2. 1:M(ONE TO MANY) 관계를 표시하는 방법
  3. M:M(MANY TO MANY) 관계를 표시하는 방법
     M:N 관계로 표현된 데이터 모델은 이후에 두 개의 주식별자를 상속받은 관계엔터티를 이용하여 3개의 엔터티로 구분하여 표현한다.
     (django : manyToManyField)

**관계선택사양(Optionality)**

필수참여관계 vs 선택참여관계

선택참여된 항목은 물리속성에서 Foreign Key로 연결될 경우 Null을 허용할 수 있는 항목이 된다.

선택참여관계는 ERD에서 관계를 나타내는 선에서 선택참여하는 엔터티 쪽을 원으로 표시한다. 필수참여는 아무런 표시를 하지 않는다.

## Identifiers

**식별자**

엔터티는 인스턴스들의 집합
여러 개의 집합체를 담고 있는 하나의 통에서 각각을 구분할 수 있는 논리적인 이름

**식별자의 특징**

**주 식별자의 특징**

- 주식별자에 의해 엔터티내의 모든 인스턴스들이 유일하도록 구분되어야 한다. **(유일성)**
- 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. **(최소성)**
- 지정된 주식별자의 값은 자주 변하지 않을 것 **(불변성)**
- 주식별자가 지정되면 값이 반드시 들어와야 한다. **(존재성)**

- 외부식별자의 경우 주식별자 특징과 일치하지 않으며 참조무결성 제약조건(Referential Integrity)에 따른 특징을 가지고 있다.

**식별자 분류 및 표기법**

- 주 식별자
  - 엔터티 내 각 occurrence를 구분할 수 있는 구분자
  - 타 엔터티와의 참조관계를 연결할 수 있는 식별자
- 보조 식별자
  - 엔터티내에서 각 어커런스를 구분할 수 있는 구분자이지만, 대표성을 가지지 못하여 참조관계 연결을 하지 못함
- 내부 식별자
  - 엔터티 내부에서 스스로 만들어지는 식별자
- 외부 식별자
  - 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자
- 단일 식별자
  - 하나의 속성으로 구성된 식별자
- 복합 식별자
  - 둘 이상의 속성
- 본질 식별자
  - 업무에 의해 만들어지는 식별자
- 인조 식별자
  - 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자

**식별자 표기법**

**주식별자 도출 기준**

- 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.
  - 보통 이름보다는 일련번호와 코드를 많이 이용한다.
  - 부서명과 같은 경우는 부서코드를 부여하여 코드엔터티에 등록한 후 부서코드로 주식별자를 지정하는 방법과 부서일련번호(부서번호)를 주식별자로 하고 부서명은 보조식별자로 활용하는 두 가지 방법이 있다.
- 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.
  - 일반적으로 주식별자의 속성의 개수가 많다는 것(일반적으로 7~8개 이상)은 새로운 인조식별자(Artificial Identifier)를 생성하여 데이터 모델을 구성하는 것이 데이터 모델을 한층 더 단순하게 하고 애플리케이션을 개발할 때 조건절을 단순하게 할 수 있는 방법이 될 수 있다.

**식별자관계와 비식별자관계에 따른 식별자**

1. 식별자 관계와 비식별자 관계의 결정

   외부식별자 : 자기 자신의 엔터티에서 필요한 속성이 아니라 다른 엔터티와의 관계안에서 자식 쪽의 엔터티에 생성되는 속성(DB에서 ForeignKey의 역할을 함)

   엔터티에 주식별자가 지정되고 엔터티간 관계를 연결하면 부모쪽의 주식별자를 자식엔터티의 속성으로 내려 보낸다. 이 때 자식엔터티에서 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 이용할 것인지 또는 부모와 연결이 되는 속성으로서만 이용할 것인지를 결정해야 한다.

2. **식별자 관계 : 자식엔터티의 주식별자로 부모의 주식별자가 상속이 되는 경우**

   부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우는 Null값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자기 자신의 엔터티가 생성된다.

   부모로부터 받은 속성을 자식엔터티가 모두 사용하고 그것만으로 주식별자로 사용한다면 부모엔터티와 자식엔터티의 관계는 1:1의 관계가 될 것이고,
   만약 부모로부터 받은 속성을 포함하여 다른 부모엔터티에서 받은 속성을 포함하거나 스스로 가지고 있는 속성과 함께 주식별자로 구성되는 경우는 1:M 관계가 된다.

3. **비식별자 관계 : 부모엔터티로부터 속성을 받았지만 자식엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우**

   아래의 경우 비식별자 관계에 의한 외부속성을 생성한다.

   1. 자식엔터티에서 받은 부모엔터티의 속성이 필수가 아니어도 되어서 부모 없는 자식이 생성될 수 있는 경우

   2. 엔터티별로 데이터의 생명주기(Life Cycle)를 다르게 관리할 경우

   예를 들어 부모엔터티의 인스턴스가 자식의 엔터티와 관계를 가지고 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우, 물리데이터베이스 생성 시 Foreign Key를 연결하지 않는 임시적인 방법을 사용하기도 하지만 데이터 모델상에서 관계를 비식별자관계로 조정하는 것이 가장 좋은 방법

   3. 여러 개의 엔터티가 하나의 엔터티로 통합되어 표현되었는데 각각의 엔터티가 별도의 관계를 가질 때

   4. 자식엔터티에 주식별자로 사용하여도 되지만 자식엔터티에서 별도의 주식별자를 생성하는 것이 더 유리하다고 판단될 때

\***\*식별자관계와 비식별자관계 모델링\*\***

1. 비식별자 관계 선택 프로세스

   - 관계가 약한 관계라면
   - 자식 테이블에서 독립적인 PK가 필요하다면
   - SQL복잡도가 증가하여 개발 생산성이 저하된다면
   - 부모 엔터티와 자식 엔터티가 생명 주기가 다른 경우

   → 비식별자 관계로 설정할 것을 고려해봐야

2. 식별자와 비식별자관계 비교
