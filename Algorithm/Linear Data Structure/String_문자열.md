# 문자열
1967년 미국에서 ASCII(American Standard Code for Information Interchange)라는 문제 인코딩 표준 제정  
ASCII : 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어문자들과 공백을 비롯한 95개의 출력가능한 문자들로 이루어짐  
확장 아스키 : 표준 문자 이외의 악센트 문자, 도형문자, 특수문자, 특수기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호  

[참고]
strlen()함수 만들어보기
```python
def strlen(a): # '\0'을 만나면 '\0'을 제외한 글자수를 리턴하는 함수를 만들어보세요
    # while문을 활용
    idx = 0
    # while a[idx] != '\0':
    #     idx += 1
    while 1:
        if a[idx] == '\0':
            return idx
        idx += 1
a = ['a', 'b', 'c', '\0']
print(strlen(a))
```
### python에서 문자열 처리
- char 타입 없음 
- 텍스트 데이터의 취급방법이 통일되어있음  
- 문자열 기호
    - '', "", ''' ''', """ """
    - '+' 연결(Concatenation) : 문자열 + 문자열 이어붙여주는 역할
    - '\*' 반복 : 문자열* 수 : 수만큼 문자열 반복
    
문자열은 sequence 자료형 
indexing, slicing 가능
immutable
replace(), find(), split(), isalpha(),

## 패턴 매칭

### 패턴 매칭에 사용되는 알고리즘
- 고지식한 패턴 검색 알고리즘
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘

#### 고지식한 패턴 검색 알고리즘 
```python
p = "is" # 찾을 패턴
t = "this is a book" # 전체 텍스트
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이

def BruteForce(p, t):
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]: # 값이 다르면 
            i = i - j # 이번 시작의 전 값으로 돌아감
            j = -1 # j는 처음부터 
        i = i + 1
        j = j + 1
    if j == M : 
        return i - M # 검색 성공
    else: 
        return -1 # 검색 실패
```
시간복잡도 : O(MN)

## KMP 알고리즘
불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행  
패턴을 전처리하여 배열 next[M]을 구하여 잘못된 시작을 최소화함  
    - next[M] : 불일치가 발생했을 경우 이동할 다음 위치  
시간 복잠도 : O(M+N)  
매칭이 실패했을 때 돌아갈 곳을 계산  
- 아이디어 설명  
텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용  
T[ ]  ...abcdabcd...  
P[ ]  ...abcdabce...  
-> 앞의 abcd만큼 건너뛰고, 뒤 abc부터 비교 재시작

## 보이어-무어 알고리즘
오른쪽에서부터 왼쪽으로 비교  
대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘  
패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴내에 존재하지 않는 경우, 이동거리는 무려 패턴의 길이만큼이 됨  
시간 복잡도 : O(N)  
